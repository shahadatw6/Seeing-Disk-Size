# -*- coding: utf-8 -*-
"""2222914_shahal_2221128_borhan.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/shahadatw6/383b0893ad5a70472d84053f5e633e55/2222914_shahal_2221128_borhan.ipynb

**Make a folder names 'STARS' in here /content/drive/MyDrive/**

**Introduction to Measuring the Seeing Disk:**

While embarking on the journey to unlock the secrets of the univers, We face this challenge called Seeing disk and Airy disk. Seeing disk is caused by the lumps of air pocket in the atmosphere. Atmosphere turbulence is a consequence of dynamic air current and temperature variation. This introduces distortion in the clarity of the image.

The seeing disk encapsulates the apparent size of the point light source mostly the stars. This directly influences the quality of the data taken for research.

**Airy Disk and Seeing Disk: A Brief Exploration of Theory**

The Airy disk and the Seeing disk are two fundamental ideas in astronomy that significantly influence how we interpret celestial observations.

**Airy Disk:**

The core of optical systems in telescopes is the Airy disk, which bears the name of the British astronomer Sir George Biddell Airy, who lived in the 19th century. A distant point source of light, such as a star, will experience diffraction as it travels through a telescope's aperture; this is the bending of light waves around the aperture's edges. A center brilliant spot surrounded by concentric rings of decreasing intensity is produced by this diffraction pattern. The Airy disk is located in the center.

The aperture diameter of the telescope determines the size of the Airy disk. Point source pictures are crisper and more detailed when larger apertures produce smaller Airy disks. The theoretical smallest point source that can occur is represented by the Airy disk.


**Seeing disk**

The Seeing Disk, on the other hand, is a useful idea that considers actual atmospheric circumstances. Because of temperature changes and air currents, Earth's atmosphere is constantly moving, which causes turbulence that impedes the clarity of astronomical views. The tumultuous atmosphere of a star causes its image to stretch out and produce a blurry area when viewed through a telescope; this is known as the "Seeing disk."

The Seeing disk is not a static, theoretical object like the Airy disk. It fluctuates according on the weather.
"""

from google.colab import drive
drive.mount('/content/drive')

import os
from PIL import Image
import matplotlib.pyplot as plt
import numpy as np

stars_folder_path = "/content/drive/MyDrive/STARS"
if os.path.exists(stars_folder_path):
    os.chdir(stars_folder_path)

    file_list = [file_name for file_name in os.listdir('.') if file_name.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp'))]

    all_images = []
    all_image_names = []

    num_images = len(file_list)
    num_cols = min(num_images, 3)
    num_rows = -(-num_images // num_cols)

    fig, axes = plt.subplots(num_rows, num_cols, figsize=(12, 8))

    for idx, file_name in enumerate(file_list):
        image = Image.open(file_name)

        grayscale_image = np.dot(np.array(image), [0.2989, 0.5870, 0.1140])

        im = axes[idx // num_cols, idx % num_cols].imshow(grayscale_image, cmap='viridis', origin='lower')
        axes[idx // num_cols, idx % num_cols].set_title(file_name)

        all_images.append(image)
        all_image_names.append(file_name)

    plt.tight_layout()

    cbar = plt.colorbar(im, ax=axes.ravel().tolist(), orientation='vertical', fraction=0.02, pad=0.1)
    cbar.set_label('Intensity', rotation=270, labelpad=15)

    plt.show()

    print("Number of Images:", len(all_images))
    print("All Image Names:", all_image_names)
else:
    print(f"Directory does not exist: {stars_folder_path}")

import cv2
import numpy as np

for image_obj, image_name in zip(all_images, all_image_names):
    image_array = np.array(image_obj)

    if image_array is not None:
        gray = cv2.cvtColor(image_array, cv2.COLOR_RGB2GRAY)

        print("Image Name:", image_name)
        print("Shape of the grayscale image:", gray.shape)
    else:
        print("Failed to load the image.")

!pip install photutils
!pip install scipy

from photutils.datasets import make_4gaussians_image
from photutils.centroids import (centroid_1dg, centroid_2dg, centroid_com, centroid_quadratic)

import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import center_of_mass

cropped_images = []

num_cols = 3

num_images = len(all_images)
num_rows = -(-num_images // num_cols)

fig, axes = plt.subplots(num_rows, num_cols, figsize=(15, 5 * num_rows))

for idx, (image_obj, fname) in enumerate(zip(all_images, all_image_names)):
    im = np.array(image_obj)
    img = np.dot(im, [0.2989, 0.5870, 0.1140])

    threshold = 0.9 * np.max(img)
    mask = img > threshold

    center_y, center_x = center_of_mass(mask)

    r = 301
    img3 = img[int(center_y) - r:int(center_y) + r, int(center_x) - r:int(center_x) + r]

    cropped_images.append(img3)

    ax = axes[idx // num_cols, idx % num_cols]
    ax.imshow(img3, origin='lower')
    ax.set_title(fname)
    ax.axis('off')

plt.tight_layout()
plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

processed_images = []

for idx, (img, img_name) in enumerate(zip(cropped_images, all_image_names)):
    cvimg = img.astype(np.uint8)

    edges = cv2.Canny(cvimg, 200, 250, apertureSize=7)

    kernel = np.ones((3, 3), np.uint8)
    dilated_edges = cv2.dilate(edges, kernel, iterations=1)

    mask = 255 - dilated_edges

    result = cv2.inpaint(cvimg, mask, inpaintRadius=3, flags=cv2.INPAINT_TELEA)

    processed_images.append(result)

    plt.figure(figsize=(10, 6))

    plt.subplot(121)
    plt.imshow(cvimg, cmap='viridis')
    plt.title(f'Original Image {idx + 1}\n{img_name}')

    plt.subplot(122)
    plt.imshow(result, cmap='viridis')
    plt.title(f'Processed Image {idx + 1}\n{img_name}')

    plt.tight_layout()
    plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

def gaussian_2d(xy, amplitude, xo, yo, sigma_x, sigma_y, theta):
    x, y = xy
    xo = float(xo)
    yo = float(yo)
    a = (np.cos(theta)**2) / (2 * sigma_x**2) + (np.sin(theta)**2) / (2 * sigma_y**2)
    b = -(np.sin(2 * theta)) / (4 * sigma_x**2) + (np.sin(2 * theta)) / (4 * sigma_y**2)
    c = (np.sin(theta)**2) / (2 * sigma_x**2) + (np.cos(theta)**2) / (2 * sigma_y**2)
    g = amplitude * np.exp(- (a * ((x - xo)**2) + 2 * b * (x - xo) * (y - yo) + c * ((y - yo)**2)))
    return g.ravel()

def estimate_fwhm(sigma_x, sigma_y):
    sigma = max(sigma_x, sigma_y)
    return 2.355 * sigma

equinox_option = input("Press 'eq' for Unistellar Equinox (or press Enter for custom values): ")

if equinox_option.lower() == 'eq':
    pixel_size = 3.75
    focal_length = 450
else:
    pixel_size = float(input("Enter the pixel size in micrometers: "))
    focal_length = float(input("Enter the focal length in millimeters: "))

arcseconds_per_pixel = (pixel_size * 206.265) / focal_length

fitted_images = []
seeing_disk_sizes = []
for idx, (img, img_name) in enumerate(zip(processed_images, all_image_names)):
    x, y = np.meshgrid(np.arange(img.shape[0]), np.arange(img.shape[1]))

    initial_guess = (1, 0, 0, 1, 1, 0)
    popt, pcov = curve_fit(gaussian_2d, (x, y), img.ravel(), p0=initial_guess)

    amplitude, xo, yo, sigma_x, sigma_y, theta = popt

    fit_data = gaussian_2d((x, y), *popt)
    fit_data = fit_data.reshape(img.shape)

    fwhm = estimate_fwhm(sigma_x, sigma_y)

    fitted_images.append(fit_data)
    seeing_disk_sizes.append(fwhm * arcseconds_per_pixel)

    plt.figure(figsize=(15, 5))

    plt.subplot(131)
    plt.imshow(img, cmap='viridis')
    plt.title(f'Original Image\n{img_name}')

    plt.subplot(132)
    plt.imshow(fit_data, cmap='viridis')
    plt.title(f'Fitted Gaussian\nFWHM: {fwhm:.2f} pixels')

    plt.subplot(133)
    plt.imshow(fit_data, cmap='viridis')
    plt.title(f'Seeing Disk\nFWHM: {fwhm * arcseconds_per_pixel:.2f} arcsec')

    plt.tight_layout()
    plt.show()

print("Seeing Disk Sizes (arcseconds):", seeing_disk_sizes)

def find_star_coordinates(image):
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    _, thresholded = cv2.threshold(gray_image, 50, 255, cv2.THRESH_BINARY)

    contours, _ = cv2.findContours(thresholded, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    if contours:
        star_contour = max(contours, key=cv2.contourArea)
        M = cv2.moments(star_contour)
        star_x = int(M["m10"] / M["m00"])
        star_y = int(M["m01"] / M["m00"])
        return star_x, star_y

    return None

magnitudes = []

for idx, (image_obj, fname) in enumerate(zip(all_images, file_list)):
    im = np.array(image_obj)

    star_coordinates = find_star_coordinates(im)

    if star_coordinates:
        star_x, star_y = star_coordinates
        star_pixel_intensity = im[star_y, star_x]

        mean_intensity = np.mean(star_pixel_intensity)

        magnitude = -2.5 * np.log10(mean_intensity)

        magnitudes.append(magnitude)

        print(f"Star {idx + 1} Magnitude: {magnitude}")
    else:
        print(f"No star found in image {idx + 1}")

# Plotting
plt.scatter(np.array(seeing_disk_sizes), magnitudes)

plt.xlim(min(magnitudes) - 5, max(magnitudes) + 10)

plt.xlabel('seeing_disk_sizes')
plt.ylabel('Magnitude')
plt.title('Star Magnitudes in Images')
plt.show()

"""**Colclusion**

We have demonstraited the application of python for quantative analysis for astronomical images. By measuring the disk size and studying the star magnitude we get a deeper understanding of the atmospheric condition affecting observations.
Although there are errors in the calculations of the magnitude for the longer exposure time , we still get to have a practical idea about the whole concept.
"""
